package portfolio

// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file types.colf.

import (
	"encoding/binary"
	"fmt"
	"io"
	"math"
	"time"
)

var intconv = binary.BigEndian

// Colfer configuration attributes
var (
	// ColferSizeMax is the upper limit for serial byte sizes.
	ColferSizeMax = 16 * 1024 * 1024
	// ColferListMax is the upper limit for the number of elements in a list.
	ColferListMax = 64 * 1024
)

// ColferMax signals an upper limit breach.
type ColferMax string

// Error honors the error interface.
func (m ColferMax) Error() string { return string(m) }

// ColferError signals a data mismatch as as a byte index.
type ColferError int

// Error honors the error interface.
func (i ColferError) Error() string {
	return fmt.Sprintf("colfer: unknown header at byte %d", i)
}

// ColferTail signals data continuation as a byte index.
type ColferTail int

// Error honors the error interface.
func (i ColferTail) Error() string {
	return fmt.Sprintf("colfer: data continuation at byte %d", i)
}

type Justification struct {
	Key string

	Value float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *Justification) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.Key); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Key)
	}

	if v := o.Value; v != 0 {
		buf[i] = 1
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *Justification) MarshalLen() (int, error) {
	l := 1

	if x := len(o.Key); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Justification.Key exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if o.Value != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.Justification exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is portfolio.ColferMax.
func (o *Justification) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *Justification) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Justification.Key size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Key = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Value = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Justification size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *Justification) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type Transaction struct {
	ID []byte

	Cleared bool

	Commission float64

	CompositeFIGI string

	Date time.Time

	Justification []*Justification

	Kind string

	Memo string

	PricePerShare float64

	Shares float64

	Source string

	SourceID []byte

	Tags []string

	TaxDisposition string

	Ticker string

	TotalValue float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
// All nil entries in o.Justification will be replaced with a new value.
func (o *Transaction) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.ID); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.ID)
	}

	if o.Cleared {
		buf[i] = 1
		i++
	}

	if v := o.Commission; v != 0 {
		buf[i] = 2
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if l := len(o.CompositeFIGI); l != 0 {
		buf[i] = 3
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.CompositeFIGI)
	}

	if v := o.Date; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 4
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 4 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if l := len(o.Justification); l != 0 {
		buf[i] = 5
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Justification {
			if v == nil {
				v = new(Justification)
				o.Justification[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if l := len(o.Kind); l != 0 {
		buf[i] = 6
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Kind)
	}

	if l := len(o.Memo); l != 0 {
		buf[i] = 7
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Memo)
	}

	if v := o.PricePerShare; v != 0 {
		buf[i] = 8
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Shares; v != 0 {
		buf[i] = 9
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if l := len(o.Source); l != 0 {
		buf[i] = 10
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Source)
	}

	if l := len(o.SourceID); l != 0 {
		buf[i] = 11
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.SourceID)
	}

	if l := len(o.Tags); l != 0 {
		buf[i] = 12
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for _, a := range o.Tags {
			x = uint(len(a))
			for x >= 0x80 {
				buf[i] = byte(x | 0x80)
				x >>= 7
				i++
			}
			buf[i] = byte(x)
			i++
			i += copy(buf[i:], a)
		}
	}

	if l := len(o.TaxDisposition); l != 0 {
		buf[i] = 13
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.TaxDisposition)
	}

	if l := len(o.Ticker); l != 0 {
		buf[i] = 14
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Ticker)
	}

	if v := o.TotalValue; v != 0 {
		buf[i] = 15
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *Transaction) MarshalLen() (int, error) {
	l := 1

	if x := len(o.ID); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Transaction.ID exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if o.Cleared {
		l++
	}

	if o.Commission != 0 {
		l += 9
	}

	if x := len(o.CompositeFIGI); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Transaction.CompositeFIGI exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if v := o.Date; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if x := len(o.Justification); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Transaction.Justification exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Justification {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Transaction size exceeds %d bytes", ColferSizeMax))
		}
	}

	if x := len(o.Kind); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Transaction.Kind exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if x := len(o.Memo); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Transaction.Memo exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if o.PricePerShare != 0 {
		l += 9
	}

	if o.Shares != 0 {
		l += 9
	}

	if x := len(o.Source); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Transaction.Source exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if x := len(o.SourceID); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Transaction.SourceID exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if x := len(o.Tags); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Transaction.Tags exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, a := range o.Tags {
			x = len(a)
			if x > ColferSizeMax {
				return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Transaction.Tags exceeds %d bytes", ColferSizeMax))
			}
			for l += x + 1; x >= 0x80; l++ {
				x >>= 7
			}
		}
		if l >= ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Transaction size exceeds %d bytes", ColferSizeMax))
		}
	}

	if x := len(o.TaxDisposition); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Transaction.TaxDisposition exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if x := len(o.Ticker); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Transaction.Ticker exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if o.TotalValue != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.Transaction exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// All nil entries in o.Justification will be replaced with a new value.
// The error return option is portfolio.ColferMax.
func (o *Transaction) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *Transaction) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction.ID size %d exceeds %d bytes", x, ColferSizeMax))
		}
		v := make([]byte, int(x))

		start := i
		i += len(v)
		if i >= len(data) {
			goto eof
		}
		copy(v, data[start:i])
		o.ID = v

		header = data[i]
		i++
	}

	if header == 1 {
		if i >= len(data) {
			goto eof
		}
		o.Cleared = true
		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Commission = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 3 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction.CompositeFIGI size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.CompositeFIGI = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 4 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Date = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 4|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.Date = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 5 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction.Justification length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*Justification, l)
		malloc := make([]Justification, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Justification = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 6 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction.Kind size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Kind = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 7 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction.Memo size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Memo = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 8 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.PricePerShare = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 9 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Shares = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 10 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction.Source size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Source = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 11 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction.SourceID size %d exceeds %d bytes", x, ColferSizeMax))
		}
		v := make([]byte, int(x))

		start := i
		i += len(v)
		if i >= len(data) {
			goto eof
		}
		copy(v, data[start:i])
		o.SourceID = v

		header = data[i]
		i++
	}

	if header == 12 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction.Tags length %d exceeds %d elements", x, ColferListMax))
		}
		a := make([]string, int(x))
		o.Tags = a

		for ai := range a {
			if i >= len(data) {
				goto eof
			}
			x := uint(data[i])
			i++

			if x >= 0x80 {
				x &= 0x7f
				for shift := uint(7); ; shift += 7 {
					if i >= len(data) {
						goto eof
					}
					b := uint(data[i])
					i++

					if b < 0x80 {
						x |= b << shift
						break
					}
					x |= (b & 0x7f) << shift
				}
			}

			if x > uint(ColferSizeMax) {
				return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction.Tags element %d size %d exceeds %d bytes", ai, x, ColferSizeMax))
			}

			start := i
			i += int(x)
			if i >= len(data) {
				goto eof
			}
			a[ai] = string(data[start:i])
		}

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 13 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction.TaxDisposition size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.TaxDisposition = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 14 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Transaction.Ticker size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Ticker = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 15 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.TotalValue = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Transaction size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *Transaction) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type Holding struct {
	Date time.Time

	Ticker string

	Shares float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *Holding) MarshalTo(buf []byte) int {
	var i int

	if v := o.Date; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 0
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 0 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if l := len(o.Ticker); l != 0 {
		buf[i] = 1
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Ticker)
	}

	if v := o.Shares; v != 0 {
		buf[i] = 2
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *Holding) MarshalLen() (int, error) {
	l := 1

	if v := o.Date; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if x := len(o.Ticker); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Holding.Ticker exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if o.Shares != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.Holding exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is portfolio.ColferMax.
func (o *Holding) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *Holding) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Date = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 0|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.Date = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 1 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Holding.Ticker size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Ticker = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Shares = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Holding size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *Holding) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type Portfolio struct {
	ID []byte

	UserID string

	Name string

	StartDate time.Time

	EndDate time.Time

	Benchmark string

	StrategyShortcode string

	StrategyArguments string

	Notifications int32

	Transactions []*Transaction

	CurrentHoldings []*Holding
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
// All nil entries in o.Transactions will be replaced with a new value.
// All nil entries in o.CurrentHoldings will be replaced with a new value.
func (o *Portfolio) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.ID); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.ID)
	}

	if l := len(o.UserID); l != 0 {
		buf[i] = 1
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.UserID)
	}

	if l := len(o.Name); l != 0 {
		buf[i] = 2
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Name)
	}

	if v := o.StartDate; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 3
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 3 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if v := o.EndDate; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 4
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 4 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if l := len(o.Benchmark); l != 0 {
		buf[i] = 5
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Benchmark)
	}

	if l := len(o.StrategyShortcode); l != 0 {
		buf[i] = 6
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.StrategyShortcode)
	}

	if l := len(o.StrategyArguments); l != 0 {
		buf[i] = 7
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.StrategyArguments)
	}

	if v := o.Notifications; v != 0 {
		x := uint32(v)
		if v >= 0 {
			buf[i] = 8
		} else {
			x = ^x + 1
			buf[i] = 8 | 0x80
		}
		i++
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
	}

	if l := len(o.Transactions); l != 0 {
		buf[i] = 9
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Transactions {
			if v == nil {
				v = new(Transaction)
				o.Transactions[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if l := len(o.CurrentHoldings); l != 0 {
		buf[i] = 10
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.CurrentHoldings {
			if v == nil {
				v = new(Holding)
				o.CurrentHoldings[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *Portfolio) MarshalLen() (int, error) {
	l := 1

	if x := len(o.ID); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Portfolio.ID exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if x := len(o.UserID); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Portfolio.UserID exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if x := len(o.Name); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Portfolio.Name exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if v := o.StartDate; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if v := o.EndDate; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if x := len(o.Benchmark); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Portfolio.Benchmark exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if x := len(o.StrategyShortcode); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Portfolio.StrategyShortcode exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if x := len(o.StrategyArguments); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Portfolio.StrategyArguments exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if v := o.Notifications; v != 0 {
		x := uint32(v)
		if v < 0 {
			x = ^x + 1
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if x := len(o.Transactions); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Portfolio.Transactions exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Transactions {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Portfolio size exceeds %d bytes", ColferSizeMax))
		}
	}

	if x := len(o.CurrentHoldings); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Portfolio.CurrentHoldings exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.CurrentHoldings {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Portfolio size exceeds %d bytes", ColferSizeMax))
		}
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.Portfolio exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// All nil entries in o.Transactions will be replaced with a new value.
// All nil entries in o.CurrentHoldings will be replaced with a new value.
// The error return option is portfolio.ColferMax.
func (o *Portfolio) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *Portfolio) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Portfolio.ID size %d exceeds %d bytes", x, ColferSizeMax))
		}
		v := make([]byte, int(x))

		start := i
		i += len(v)
		if i >= len(data) {
			goto eof
		}
		copy(v, data[start:i])
		o.ID = v

		header = data[i]
		i++
	}

	if header == 1 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Portfolio.UserID size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.UserID = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 2 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Portfolio.Name size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Name = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 3 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.StartDate = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 3|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.StartDate = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 4 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.EndDate = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 4|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.EndDate = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 5 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Portfolio.Benchmark size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Benchmark = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 6 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Portfolio.StrategyShortcode size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.StrategyShortcode = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 7 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Portfolio.StrategyArguments size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.StrategyArguments = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 8 {
		if i+1 >= len(data) {
			i++
			goto eof
		}
		x := uint32(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				b := uint32(data[i])
				i++
				if i >= len(data) {
					goto eof
				}

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}
		o.Notifications = int32(x)

		header = data[i]
		i++
	} else if header == 8|0x80 {
		if i+1 >= len(data) {
			i++
			goto eof
		}
		x := uint32(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				b := uint32(data[i])
				i++
				if i >= len(data) {
					goto eof
				}

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}
		o.Notifications = int32(^x + 1)

		header = data[i]
		i++
	}

	if header == 9 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Portfolio.Transactions length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*Transaction, l)
		malloc := make([]Transaction, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Portfolio size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Transactions = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 10 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Portfolio.CurrentHoldings length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*Holding, l)
		malloc := make([]Holding, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Portfolio size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.CurrentHoldings = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Portfolio size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *Portfolio) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type DrawDown struct {
	Begin time.Time

	End time.Time

	Recovery time.Time

	LossPercent float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *DrawDown) MarshalTo(buf []byte) int {
	var i int

	if v := o.Begin; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 0
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 0 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if v := o.End; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 1
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 1 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if v := o.Recovery; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 2
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 2 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if v := o.LossPercent; v != 0 {
		buf[i] = 3
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *DrawDown) MarshalLen() (int, error) {
	l := 1

	if v := o.Begin; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if v := o.End; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if v := o.Recovery; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if o.LossPercent != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.DrawDown exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is portfolio.ColferMax.
func (o *DrawDown) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *DrawDown) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Begin = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 0|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.Begin = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.End = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 1|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.End = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Recovery = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 2|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.Recovery = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 3 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.LossPercent = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.DrawDown size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *DrawDown) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type AnnualReturn struct {
	Year uint16

	Return float32
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *AnnualReturn) MarshalTo(buf []byte) int {
	var i int

	if x := o.Year; x >= 1<<8 {
		buf[i] = 0
		i++
		buf[i] = byte(x >> 8)
		i++
		buf[i] = byte(x)
		i++
	} else if x != 0 {
		buf[i] = 0 | 0x80
		i++
		buf[i] = byte(x)
		i++
	}

	if v := o.Return; v != 0 {
		buf[i] = 1
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *AnnualReturn) MarshalLen() (int, error) {
	l := 1

	if x := o.Year; x >= 1<<8 {
		l += 3
	} else if x != 0 {
		l += 2
	}

	if o.Return != 0 {
		l += 5
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.AnnualReturn exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is portfolio.ColferMax.
func (o *AnnualReturn) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *AnnualReturn) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		start := i
		i += 2
		if i >= len(data) {
			goto eof
		}
		o.Year = intconv.Uint16(data[start:])
		header = data[i]
		i++
	} else if header == 0|0x80 {
		start := i
		i++
		if i >= len(data) {
			goto eof
		}
		o.Year = uint16(data[start])
		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.Return = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.AnnualReturn size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *AnnualReturn) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type Metrics struct {
	AlphaSinceInception float64

	AvgDrawDown float64

	BestYear *AnnualReturn

	BetaSinceInception float64

	DownsideDeviationSinceInception float64

	ExcessKurtosisSinceInception float64

	FinalBalance float64

	SharpeRatioSinceInception float64

	Skewness float64

	SortinoRatioSinceInception float64

	StdDevSinceInception float64

	TotalDeposited float64

	TotalWithdrawn float64

	UlcerIndexAvg float64

	UlcerIndexP50 float64

	UlcerIndexP90 float64

	UlcerIndexP99 float64

	WorstYear *AnnualReturn

	DynamicWithdrawalRateSinceInception float64

	PerpetualWithdrawalRateSinceInception float64

	SafeWithdrawalRateSinceInception float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *Metrics) MarshalTo(buf []byte) int {
	var i int

	if v := o.AlphaSinceInception; v != 0 {
		buf[i] = 0
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.AvgDrawDown; v != 0 {
		buf[i] = 1
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.BestYear; v != nil {
		buf[i] = 2
		i++
		i += v.MarshalTo(buf[i:])
	}

	if v := o.BetaSinceInception; v != 0 {
		buf[i] = 3
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.DownsideDeviationSinceInception; v != 0 {
		buf[i] = 4
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.ExcessKurtosisSinceInception; v != 0 {
		buf[i] = 5
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.FinalBalance; v != 0 {
		buf[i] = 6
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.SharpeRatioSinceInception; v != 0 {
		buf[i] = 7
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Skewness; v != 0 {
		buf[i] = 8
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.SortinoRatioSinceInception; v != 0 {
		buf[i] = 9
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.StdDevSinceInception; v != 0 {
		buf[i] = 10
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.TotalDeposited; v != 0 {
		buf[i] = 11
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.TotalWithdrawn; v != 0 {
		buf[i] = 12
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.UlcerIndexAvg; v != 0 {
		buf[i] = 13
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.UlcerIndexP50; v != 0 {
		buf[i] = 14
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.UlcerIndexP90; v != 0 {
		buf[i] = 15
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.UlcerIndexP99; v != 0 {
		buf[i] = 16
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.WorstYear; v != nil {
		buf[i] = 17
		i++
		i += v.MarshalTo(buf[i:])
	}

	if v := o.DynamicWithdrawalRateSinceInception; v != 0 {
		buf[i] = 18
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.PerpetualWithdrawalRateSinceInception; v != 0 {
		buf[i] = 19
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.SafeWithdrawalRateSinceInception; v != 0 {
		buf[i] = 20
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *Metrics) MarshalLen() (int, error) {
	l := 1

	if o.AlphaSinceInception != 0 {
		l += 9
	}

	if o.AvgDrawDown != 0 {
		l += 9
	}

	if v := o.BestYear; v != nil {
		vl, err := v.MarshalLen()
		if err != nil {
			return 0, err
		}
		l += vl + 1
	}

	if o.BetaSinceInception != 0 {
		l += 9
	}

	if o.DownsideDeviationSinceInception != 0 {
		l += 9
	}

	if o.ExcessKurtosisSinceInception != 0 {
		l += 9
	}

	if o.FinalBalance != 0 {
		l += 9
	}

	if o.SharpeRatioSinceInception != 0 {
		l += 9
	}

	if o.Skewness != 0 {
		l += 9
	}

	if o.SortinoRatioSinceInception != 0 {
		l += 9
	}

	if o.StdDevSinceInception != 0 {
		l += 9
	}

	if o.TotalDeposited != 0 {
		l += 9
	}

	if o.TotalWithdrawn != 0 {
		l += 9
	}

	if o.UlcerIndexAvg != 0 {
		l += 9
	}

	if o.UlcerIndexP50 != 0 {
		l += 9
	}

	if o.UlcerIndexP90 != 0 {
		l += 9
	}

	if o.UlcerIndexP99 != 0 {
		l += 9
	}

	if v := o.WorstYear; v != nil {
		vl, err := v.MarshalLen()
		if err != nil {
			return 0, err
		}
		l += vl + 1
	}

	if o.DynamicWithdrawalRateSinceInception != 0 {
		l += 9
	}

	if o.PerpetualWithdrawalRateSinceInception != 0 {
		l += 9
	}

	if o.SafeWithdrawalRateSinceInception != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.Metrics exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is portfolio.ColferMax.
func (o *Metrics) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *Metrics) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.AlphaSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.AvgDrawDown = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 2 {
		o.BestYear = new(AnnualReturn)
		n, err := o.BestYear.Unmarshal(data[i:])
		if err != nil {
			if err == io.EOF && len(data) >= ColferSizeMax {
				return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Metrics size exceeds %d bytes", ColferSizeMax))
			}
			return 0, err
		}
		i += n

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 3 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.BetaSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 4 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.DownsideDeviationSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 5 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.ExcessKurtosisSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 6 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.FinalBalance = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 7 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.SharpeRatioSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 8 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Skewness = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 9 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.SortinoRatioSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 10 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.StdDevSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 11 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.TotalDeposited = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 12 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.TotalWithdrawn = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 13 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.UlcerIndexAvg = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 14 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.UlcerIndexP50 = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 15 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.UlcerIndexP90 = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 16 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.UlcerIndexP99 = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 17 {
		o.WorstYear = new(AnnualReturn)
		n, err := o.WorstYear.Unmarshal(data[i:])
		if err != nil {
			if err == io.EOF && len(data) >= ColferSizeMax {
				return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Metrics size exceeds %d bytes", ColferSizeMax))
			}
			return 0, err
		}
		i += n

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 18 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.DynamicWithdrawalRateSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 19 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.PerpetualWithdrawalRateSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 20 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.SafeWithdrawalRateSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Metrics size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *Metrics) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type Performance struct {
	PortfolioID []byte

	PeriodStart time.Time

	PeriodEnd time.Time

	ComputedOn time.Time

	CurrentAssets []*ReportableHolding

	Measurements []*PerformanceMeasurement

	DrawDowns []*DrawDown

	PortfolioReturns *Returns

	BenchmarkReturns *Returns

	PortfolioMetrics *Metrics

	BenchmarkMetrics *Metrics
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
// All nil entries in o.CurrentAssets will be replaced with a new value.
// All nil entries in o.Measurements will be replaced with a new value.
// All nil entries in o.DrawDowns will be replaced with a new value.
func (o *Performance) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.PortfolioID); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.PortfolioID)
	}

	if v := o.PeriodStart; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 1
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 1 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if v := o.PeriodEnd; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 2
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 2 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if v := o.ComputedOn; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 3
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 3 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if l := len(o.CurrentAssets); l != 0 {
		buf[i] = 4
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.CurrentAssets {
			if v == nil {
				v = new(ReportableHolding)
				o.CurrentAssets[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if l := len(o.Measurements); l != 0 {
		buf[i] = 5
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Measurements {
			if v == nil {
				v = new(PerformanceMeasurement)
				o.Measurements[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if l := len(o.DrawDowns); l != 0 {
		buf[i] = 6
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.DrawDowns {
			if v == nil {
				v = new(DrawDown)
				o.DrawDowns[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if v := o.PortfolioReturns; v != nil {
		buf[i] = 7
		i++
		i += v.MarshalTo(buf[i:])
	}

	if v := o.BenchmarkReturns; v != nil {
		buf[i] = 8
		i++
		i += v.MarshalTo(buf[i:])
	}

	if v := o.PortfolioMetrics; v != nil {
		buf[i] = 9
		i++
		i += v.MarshalTo(buf[i:])
	}

	if v := o.BenchmarkMetrics; v != nil {
		buf[i] = 10
		i++
		i += v.MarshalTo(buf[i:])
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *Performance) MarshalLen() (int, error) {
	l := 1

	if x := len(o.PortfolioID); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Performance.PortfolioID exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if v := o.PeriodStart; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if v := o.PeriodEnd; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if v := o.ComputedOn; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if x := len(o.CurrentAssets); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Performance.CurrentAssets exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.CurrentAssets {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Performance size exceeds %d bytes", ColferSizeMax))
		}
	}

	if x := len(o.Measurements); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Performance.Measurements exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Measurements {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Performance size exceeds %d bytes", ColferSizeMax))
		}
	}

	if x := len(o.DrawDowns); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.Performance.DrawDowns exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.DrawDowns {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Performance size exceeds %d bytes", ColferSizeMax))
		}
	}

	if v := o.PortfolioReturns; v != nil {
		vl, err := v.MarshalLen()
		if err != nil {
			return 0, err
		}
		l += vl + 1
	}

	if v := o.BenchmarkReturns; v != nil {
		vl, err := v.MarshalLen()
		if err != nil {
			return 0, err
		}
		l += vl + 1
	}

	if v := o.PortfolioMetrics; v != nil {
		vl, err := v.MarshalLen()
		if err != nil {
			return 0, err
		}
		l += vl + 1
	}

	if v := o.BenchmarkMetrics; v != nil {
		vl, err := v.MarshalLen()
		if err != nil {
			return 0, err
		}
		l += vl + 1
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.Performance exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// All nil entries in o.CurrentAssets will be replaced with a new value.
// All nil entries in o.Measurements will be replaced with a new value.
// All nil entries in o.DrawDowns will be replaced with a new value.
// The error return option is portfolio.ColferMax.
func (o *Performance) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *Performance) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Performance.PortfolioID size %d exceeds %d bytes", x, ColferSizeMax))
		}
		v := make([]byte, int(x))

		start := i
		i += len(v)
		if i >= len(data) {
			goto eof
		}
		copy(v, data[start:i])
		o.PortfolioID = v

		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.PeriodStart = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 1|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.PeriodStart = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.PeriodEnd = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 2|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.PeriodEnd = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 3 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.ComputedOn = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 3|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.ComputedOn = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 4 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Performance.CurrentAssets length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*ReportableHolding, l)
		malloc := make([]ReportableHolding, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Performance size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.CurrentAssets = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 5 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Performance.Measurements length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*PerformanceMeasurement, l)
		malloc := make([]PerformanceMeasurement, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Performance size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Measurements = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 6 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Performance.DrawDowns length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*DrawDown, l)
		malloc := make([]DrawDown, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Performance size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.DrawDowns = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 7 {
		o.PortfolioReturns = new(Returns)
		n, err := o.PortfolioReturns.Unmarshal(data[i:])
		if err != nil {
			if err == io.EOF && len(data) >= ColferSizeMax {
				return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Performance size exceeds %d bytes", ColferSizeMax))
			}
			return 0, err
		}
		i += n

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 8 {
		o.BenchmarkReturns = new(Returns)
		n, err := o.BenchmarkReturns.Unmarshal(data[i:])
		if err != nil {
			if err == io.EOF && len(data) >= ColferSizeMax {
				return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Performance size exceeds %d bytes", ColferSizeMax))
			}
			return 0, err
		}
		i += n

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 9 {
		o.PortfolioMetrics = new(Metrics)
		n, err := o.PortfolioMetrics.Unmarshal(data[i:])
		if err != nil {
			if err == io.EOF && len(data) >= ColferSizeMax {
				return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Performance size exceeds %d bytes", ColferSizeMax))
			}
			return 0, err
		}
		i += n

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 10 {
		o.BenchmarkMetrics = new(Metrics)
		n, err := o.BenchmarkMetrics.Unmarshal(data[i:])
		if err != nil {
			if err == io.EOF && len(data) >= ColferSizeMax {
				return 0, ColferMax(fmt.Sprintf("colfer: portfolio.Performance size exceeds %d bytes", ColferSizeMax))
			}
			return 0, err
		}
		i += n

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Performance size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *Performance) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type PerformanceMeasurementItem struct {
	Time time.Time

	Value1 float64

	Value2 float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *PerformanceMeasurementItem) MarshalTo(buf []byte) int {
	var i int

	if v := o.Time; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 0
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 0 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if v := o.Value1; v != 0 {
		buf[i] = 1
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Value2; v != 0 {
		buf[i] = 2
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *PerformanceMeasurementItem) MarshalLen() (int, error) {
	l := 1

	if v := o.Time; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if o.Value1 != 0 {
		l += 9
	}

	if o.Value2 != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.PerformanceMeasurementItem exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is portfolio.ColferMax.
func (o *PerformanceMeasurementItem) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *PerformanceMeasurementItem) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Time = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 0|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.Time = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Value1 = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Value2 = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PerformanceMeasurementItem size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *PerformanceMeasurementItem) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type PerformanceMeasurementItemList struct {
	Items []*PerformanceMeasurementItem

	FieldNames []string
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
// All nil entries in o.Items will be replaced with a new value.
func (o *PerformanceMeasurementItemList) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.Items); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Items {
			if v == nil {
				v = new(PerformanceMeasurementItem)
				o.Items[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if l := len(o.FieldNames); l != 0 {
		buf[i] = 1
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for _, a := range o.FieldNames {
			x = uint(len(a))
			for x >= 0x80 {
				buf[i] = byte(x | 0x80)
				x >>= 7
				i++
			}
			buf[i] = byte(x)
			i++
			i += copy(buf[i:], a)
		}
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *PerformanceMeasurementItemList) MarshalLen() (int, error) {
	l := 1

	if x := len(o.Items); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.PerformanceMeasurementItemList.Items exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Items {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PerformanceMeasurementItemList size exceeds %d bytes", ColferSizeMax))
		}
	}

	if x := len(o.FieldNames); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.PerformanceMeasurementItemList.FieldNames exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, a := range o.FieldNames {
			x = len(a)
			if x > ColferSizeMax {
				return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.PerformanceMeasurementItemList.FieldNames exceeds %d bytes", ColferSizeMax))
			}
			for l += x + 1; x >= 0x80; l++ {
				x >>= 7
			}
		}
		if l >= ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PerformanceMeasurementItemList size exceeds %d bytes", ColferSizeMax))
		}
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.PerformanceMeasurementItemList exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// All nil entries in o.Items will be replaced with a new value.
// The error return option is portfolio.ColferMax.
func (o *PerformanceMeasurementItemList) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *PerformanceMeasurementItemList) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PerformanceMeasurementItemList.Items length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*PerformanceMeasurementItem, l)
		malloc := make([]PerformanceMeasurementItem, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PerformanceMeasurementItemList size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Items = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 1 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PerformanceMeasurementItemList.FieldNames length %d exceeds %d elements", x, ColferListMax))
		}
		a := make([]string, int(x))
		o.FieldNames = a

		for ai := range a {
			if i >= len(data) {
				goto eof
			}
			x := uint(data[i])
			i++

			if x >= 0x80 {
				x &= 0x7f
				for shift := uint(7); ; shift += 7 {
					if i >= len(data) {
						goto eof
					}
					b := uint(data[i])
					i++

					if b < 0x80 {
						x |= b << shift
						break
					}
					x |= (b & 0x7f) << shift
				}
			}

			if x > uint(ColferSizeMax) {
				return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PerformanceMeasurementItemList.FieldNames element %d size %d exceeds %d bytes", ai, x, ColferSizeMax))
			}

			start := i
			i += int(x)
			if i >= len(data) {
				goto eof
			}
			a[ai] = string(data[start:i])
		}

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PerformanceMeasurementItemList size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *PerformanceMeasurementItemList) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type PerformanceMeasurement struct {
	Time time.Time

	Value float64

	BenchmarkValue float64

	RiskFreeValue float64

	StrategyGrowthOf10K float64

	BenchmarkGrowthOf10K float64

	RiskFreeGrowthOf10K float64

	Holdings []*ReportableHolding

	Justification []*Justification

	TotalDeposited float64

	TotalWithdrawn float64
	// Time-weighted rate of return
	TWRROneDay float32

	TWRRWeekToDate float32

	TWRROneWeek float32

	TWRRMonthToDate float32

	TWRROneMonth float32

	TWRRThreeMonth float32

	TWRRYearToDate float32

	TWRROneYear float32

	TWRRThreeYear float32

	TWRRFiveYear float32

	TWRRTenYear float32
	// Money-weighted rate of return
	MWRROneDay float32

	MWRRWeekToDate float32

	MWRROneWeek float32

	MWRRMonthToDate float32

	MWRROneMonth float32

	MWRRThreeMonth float32

	MWRRYearToDate float32

	MWRROneYear float32

	MWRRThreeYear float32

	MWRRFiveYear float32

	MWRRTenYear float32
	// active return
	ActiveReturnOneYear float32

	ActiveReturnThreeYear float32

	ActiveReturnFiveYear float32

	ActiveReturnTenYear float32
	// alpha
	AlphaOneYear float32

	AlphaThreeYear float32

	AlphaFiveYear float32

	AlphaTenYear float32
	// beta
	BetaOneYear float32

	BetaThreeYear float32

	BetaFiveYear float32

	BetaTenYear float32
	// ratios
	CalmarRatio float32

	DownsideDeviation float32

	InformationRatio float32

	KRatio float32

	KellerRatio float32

	SharpeRatio float32

	SortinoRatio float32

	StdDev float32

	TreynorRatio float32

	UlcerIndex float32
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
// All nil entries in o.Holdings will be replaced with a new value.
// All nil entries in o.Justification will be replaced with a new value.
func (o *PerformanceMeasurement) MarshalTo(buf []byte) int {
	var i int

	if v := o.Time; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 0
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 0 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if v := o.Value; v != 0 {
		buf[i] = 1
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.BenchmarkValue; v != 0 {
		buf[i] = 2
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.RiskFreeValue; v != 0 {
		buf[i] = 3
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.StrategyGrowthOf10K; v != 0 {
		buf[i] = 4
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.BenchmarkGrowthOf10K; v != 0 {
		buf[i] = 5
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.RiskFreeGrowthOf10K; v != 0 {
		buf[i] = 6
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if l := len(o.Holdings); l != 0 {
		buf[i] = 7
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Holdings {
			if v == nil {
				v = new(ReportableHolding)
				o.Holdings[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if l := len(o.Justification); l != 0 {
		buf[i] = 8
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Justification {
			if v == nil {
				v = new(Justification)
				o.Justification[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if v := o.TotalDeposited; v != 0 {
		buf[i] = 9
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.TotalWithdrawn; v != 0 {
		buf[i] = 10
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.TWRROneDay; v != 0 {
		buf[i] = 11
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.TWRRWeekToDate; v != 0 {
		buf[i] = 12
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.TWRROneWeek; v != 0 {
		buf[i] = 13
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.TWRRMonthToDate; v != 0 {
		buf[i] = 14
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.TWRROneMonth; v != 0 {
		buf[i] = 15
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.TWRRThreeMonth; v != 0 {
		buf[i] = 16
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.TWRRYearToDate; v != 0 {
		buf[i] = 17
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.TWRROneYear; v != 0 {
		buf[i] = 18
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.TWRRThreeYear; v != 0 {
		buf[i] = 19
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.TWRRFiveYear; v != 0 {
		buf[i] = 20
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.TWRRTenYear; v != 0 {
		buf[i] = 21
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.MWRROneDay; v != 0 {
		buf[i] = 22
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.MWRRWeekToDate; v != 0 {
		buf[i] = 23
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.MWRROneWeek; v != 0 {
		buf[i] = 24
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.MWRRMonthToDate; v != 0 {
		buf[i] = 25
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.MWRROneMonth; v != 0 {
		buf[i] = 26
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.MWRRThreeMonth; v != 0 {
		buf[i] = 27
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.MWRRYearToDate; v != 0 {
		buf[i] = 28
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.MWRROneYear; v != 0 {
		buf[i] = 29
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.MWRRThreeYear; v != 0 {
		buf[i] = 30
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.MWRRFiveYear; v != 0 {
		buf[i] = 31
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.MWRRTenYear; v != 0 {
		buf[i] = 32
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.ActiveReturnOneYear; v != 0 {
		buf[i] = 33
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.ActiveReturnThreeYear; v != 0 {
		buf[i] = 34
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.ActiveReturnFiveYear; v != 0 {
		buf[i] = 35
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.ActiveReturnTenYear; v != 0 {
		buf[i] = 36
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.AlphaOneYear; v != 0 {
		buf[i] = 37
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.AlphaThreeYear; v != 0 {
		buf[i] = 38
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.AlphaFiveYear; v != 0 {
		buf[i] = 39
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.AlphaTenYear; v != 0 {
		buf[i] = 40
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.BetaOneYear; v != 0 {
		buf[i] = 41
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.BetaThreeYear; v != 0 {
		buf[i] = 42
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.BetaFiveYear; v != 0 {
		buf[i] = 43
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.BetaTenYear; v != 0 {
		buf[i] = 44
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.CalmarRatio; v != 0 {
		buf[i] = 45
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.DownsideDeviation; v != 0 {
		buf[i] = 46
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.InformationRatio; v != 0 {
		buf[i] = 47
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.KRatio; v != 0 {
		buf[i] = 48
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.KellerRatio; v != 0 {
		buf[i] = 49
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.SharpeRatio; v != 0 {
		buf[i] = 50
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.SortinoRatio; v != 0 {
		buf[i] = 51
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.StdDev; v != 0 {
		buf[i] = 52
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.TreynorRatio; v != 0 {
		buf[i] = 53
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.UlcerIndex; v != 0 {
		buf[i] = 54
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *PerformanceMeasurement) MarshalLen() (int, error) {
	l := 1

	if v := o.Time; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if o.Value != 0 {
		l += 9
	}

	if o.BenchmarkValue != 0 {
		l += 9
	}

	if o.RiskFreeValue != 0 {
		l += 9
	}

	if o.StrategyGrowthOf10K != 0 {
		l += 9
	}

	if o.BenchmarkGrowthOf10K != 0 {
		l += 9
	}

	if o.RiskFreeGrowthOf10K != 0 {
		l += 9
	}

	if x := len(o.Holdings); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.PerformanceMeasurement.Holdings exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Holdings {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PerformanceMeasurement size exceeds %d bytes", ColferSizeMax))
		}
	}

	if x := len(o.Justification); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.PerformanceMeasurement.Justification exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Justification {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PerformanceMeasurement size exceeds %d bytes", ColferSizeMax))
		}
	}

	if o.TotalDeposited != 0 {
		l += 9
	}

	if o.TotalWithdrawn != 0 {
		l += 9
	}

	if o.TWRROneDay != 0 {
		l += 5
	}

	if o.TWRRWeekToDate != 0 {
		l += 5
	}

	if o.TWRROneWeek != 0 {
		l += 5
	}

	if o.TWRRMonthToDate != 0 {
		l += 5
	}

	if o.TWRROneMonth != 0 {
		l += 5
	}

	if o.TWRRThreeMonth != 0 {
		l += 5
	}

	if o.TWRRYearToDate != 0 {
		l += 5
	}

	if o.TWRROneYear != 0 {
		l += 5
	}

	if o.TWRRThreeYear != 0 {
		l += 5
	}

	if o.TWRRFiveYear != 0 {
		l += 5
	}

	if o.TWRRTenYear != 0 {
		l += 5
	}

	if o.MWRROneDay != 0 {
		l += 5
	}

	if o.MWRRWeekToDate != 0 {
		l += 5
	}

	if o.MWRROneWeek != 0 {
		l += 5
	}

	if o.MWRRMonthToDate != 0 {
		l += 5
	}

	if o.MWRROneMonth != 0 {
		l += 5
	}

	if o.MWRRThreeMonth != 0 {
		l += 5
	}

	if o.MWRRYearToDate != 0 {
		l += 5
	}

	if o.MWRROneYear != 0 {
		l += 5
	}

	if o.MWRRThreeYear != 0 {
		l += 5
	}

	if o.MWRRFiveYear != 0 {
		l += 5
	}

	if o.MWRRTenYear != 0 {
		l += 5
	}

	if o.ActiveReturnOneYear != 0 {
		l += 5
	}

	if o.ActiveReturnThreeYear != 0 {
		l += 5
	}

	if o.ActiveReturnFiveYear != 0 {
		l += 5
	}

	if o.ActiveReturnTenYear != 0 {
		l += 5
	}

	if o.AlphaOneYear != 0 {
		l += 5
	}

	if o.AlphaThreeYear != 0 {
		l += 5
	}

	if o.AlphaFiveYear != 0 {
		l += 5
	}

	if o.AlphaTenYear != 0 {
		l += 5
	}

	if o.BetaOneYear != 0 {
		l += 5
	}

	if o.BetaThreeYear != 0 {
		l += 5
	}

	if o.BetaFiveYear != 0 {
		l += 5
	}

	if o.BetaTenYear != 0 {
		l += 5
	}

	if o.CalmarRatio != 0 {
		l += 5
	}

	if o.DownsideDeviation != 0 {
		l += 5
	}

	if o.InformationRatio != 0 {
		l += 5
	}

	if o.KRatio != 0 {
		l += 5
	}

	if o.KellerRatio != 0 {
		l += 5
	}

	if o.SharpeRatio != 0 {
		l += 5
	}

	if o.SortinoRatio != 0 {
		l += 5
	}

	if o.StdDev != 0 {
		l += 5
	}

	if o.TreynorRatio != 0 {
		l += 5
	}

	if o.UlcerIndex != 0 {
		l += 5
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.PerformanceMeasurement exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// All nil entries in o.Holdings will be replaced with a new value.
// All nil entries in o.Justification will be replaced with a new value.
// The error return option is portfolio.ColferMax.
func (o *PerformanceMeasurement) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *PerformanceMeasurement) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Time = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 0|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.Time = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Value = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.BenchmarkValue = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 3 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.RiskFreeValue = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 4 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.StrategyGrowthOf10K = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 5 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.BenchmarkGrowthOf10K = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 6 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.RiskFreeGrowthOf10K = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 7 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PerformanceMeasurement.Holdings length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*ReportableHolding, l)
		malloc := make([]ReportableHolding, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PerformanceMeasurement size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Holdings = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 8 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PerformanceMeasurement.Justification length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*Justification, l)
		malloc := make([]Justification, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PerformanceMeasurement size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Justification = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 9 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.TotalDeposited = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 10 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.TotalWithdrawn = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 11 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TWRROneDay = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 12 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TWRRWeekToDate = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 13 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TWRROneWeek = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 14 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TWRRMonthToDate = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 15 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TWRROneMonth = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 16 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TWRRThreeMonth = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 17 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TWRRYearToDate = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 18 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TWRROneYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 19 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TWRRThreeYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 20 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TWRRFiveYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 21 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TWRRTenYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 22 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.MWRROneDay = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 23 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.MWRRWeekToDate = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 24 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.MWRROneWeek = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 25 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.MWRRMonthToDate = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 26 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.MWRROneMonth = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 27 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.MWRRThreeMonth = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 28 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.MWRRYearToDate = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 29 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.MWRROneYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 30 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.MWRRThreeYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 31 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.MWRRFiveYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 32 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.MWRRTenYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 33 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.ActiveReturnOneYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 34 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.ActiveReturnThreeYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 35 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.ActiveReturnFiveYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 36 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.ActiveReturnTenYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 37 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.AlphaOneYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 38 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.AlphaThreeYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 39 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.AlphaFiveYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 40 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.AlphaTenYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 41 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.BetaOneYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 42 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.BetaThreeYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 43 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.BetaFiveYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 44 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.BetaTenYear = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 45 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.CalmarRatio = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 46 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.DownsideDeviation = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 47 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.InformationRatio = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 48 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.KRatio = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 49 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.KellerRatio = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 50 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.SharpeRatio = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 51 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.SortinoRatio = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 52 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.StdDev = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 53 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.TreynorRatio = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 54 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.UlcerIndex = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PerformanceMeasurement size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *PerformanceMeasurement) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type ReportableHolding struct {
	Ticker string

	Shares float64

	PercentPortfolio float32

	Value float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *ReportableHolding) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.Ticker); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Ticker)
	}

	if v := o.Shares; v != 0 {
		buf[i] = 1
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.PercentPortfolio; v != 0 {
		buf[i] = 2
		intconv.PutUint32(buf[i+1:], math.Float32bits(v))
		i += 5
	}

	if v := o.Value; v != 0 {
		buf[i] = 3
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *ReportableHolding) MarshalLen() (int, error) {
	l := 1

	if x := len(o.Ticker); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.ReportableHolding.Ticker exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if o.Shares != 0 {
		l += 9
	}

	if o.PercentPortfolio != 0 {
		l += 5
	}

	if o.Value != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.ReportableHolding exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is portfolio.ColferMax.
func (o *ReportableHolding) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *ReportableHolding) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.ReportableHolding.Ticker size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Ticker = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Shares = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 4
		if i >= len(data) {
			goto eof
		}
		o.PercentPortfolio = math.Float32frombits(intconv.Uint32(data[start:]))
		header = data[i]
		i++
	}

	if header == 3 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Value = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.ReportableHolding size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *ReportableHolding) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type Returns struct {
	MWRRSinceInception float64

	MWRRYTD float64

	MWRROneYear float64

	MWRRThreeYear float64

	MWRRFiveYear float64

	MWRRTenYear float64

	TWRRSinceInception float64

	TWRRYTD float64

	TWRROneYear float64

	TWRRThreeYear float64

	TWRRFiveYear float64

	TWRRTenYear float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *Returns) MarshalTo(buf []byte) int {
	var i int

	if v := o.MWRRSinceInception; v != 0 {
		buf[i] = 0
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.MWRRYTD; v != 0 {
		buf[i] = 1
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.MWRROneYear; v != 0 {
		buf[i] = 2
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.MWRRThreeYear; v != 0 {
		buf[i] = 3
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.MWRRFiveYear; v != 0 {
		buf[i] = 4
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.MWRRTenYear; v != 0 {
		buf[i] = 5
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.TWRRSinceInception; v != 0 {
		buf[i] = 6
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.TWRRYTD; v != 0 {
		buf[i] = 7
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.TWRROneYear; v != 0 {
		buf[i] = 8
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.TWRRThreeYear; v != 0 {
		buf[i] = 9
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.TWRRFiveYear; v != 0 {
		buf[i] = 10
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.TWRRTenYear; v != 0 {
		buf[i] = 11
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *Returns) MarshalLen() (int, error) {
	l := 1

	if o.MWRRSinceInception != 0 {
		l += 9
	}

	if o.MWRRYTD != 0 {
		l += 9
	}

	if o.MWRROneYear != 0 {
		l += 9
	}

	if o.MWRRThreeYear != 0 {
		l += 9
	}

	if o.MWRRFiveYear != 0 {
		l += 9
	}

	if o.MWRRTenYear != 0 {
		l += 9
	}

	if o.TWRRSinceInception != 0 {
		l += 9
	}

	if o.TWRRYTD != 0 {
		l += 9
	}

	if o.TWRROneYear != 0 {
		l += 9
	}

	if o.TWRRThreeYear != 0 {
		l += 9
	}

	if o.TWRRFiveYear != 0 {
		l += 9
	}

	if o.TWRRTenYear != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.Returns exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is portfolio.ColferMax.
func (o *Returns) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *Returns) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.MWRRSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.MWRRYTD = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.MWRROneYear = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 3 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.MWRRThreeYear = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 4 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.MWRRFiveYear = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 5 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.MWRRTenYear = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 6 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.TWRRSinceInception = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 7 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.TWRRYTD = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 8 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.TWRROneYear = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 9 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.TWRRThreeYear = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 10 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.TWRRFiveYear = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 11 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.TWRRTenYear = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.Returns size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *Returns) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type PortfolioHoldingItem struct {
	Time time.Time

	Holdings []*ReportableHolding

	Justification []*Justification

	PercentReturn float64

	Value float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
// All nil entries in o.Holdings will be replaced with a new value.
// All nil entries in o.Justification will be replaced with a new value.
func (o *PortfolioHoldingItem) MarshalTo(buf []byte) int {
	var i int

	if v := o.Time; !v.IsZero() {
		s, ns := uint64(v.Unix()), uint32(v.Nanosecond())
		if s < 1<<32 {
			buf[i] = 0
			intconv.PutUint32(buf[i+1:], uint32(s))
			i += 5
		} else {
			buf[i] = 0 | 0x80
			intconv.PutUint64(buf[i+1:], s)
			i += 9
		}
		intconv.PutUint32(buf[i:], ns)
		i += 4
	}

	if l := len(o.Holdings); l != 0 {
		buf[i] = 1
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Holdings {
			if v == nil {
				v = new(ReportableHolding)
				o.Holdings[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if l := len(o.Justification); l != 0 {
		buf[i] = 2
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Justification {
			if v == nil {
				v = new(Justification)
				o.Justification[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if v := o.PercentReturn; v != 0 {
		buf[i] = 3
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Value; v != 0 {
		buf[i] = 4
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *PortfolioHoldingItem) MarshalLen() (int, error) {
	l := 1

	if v := o.Time; !v.IsZero() {
		if s := uint64(v.Unix()); s < 1<<32 {
			l += 9
		} else {
			l += 13
		}
	}

	if x := len(o.Holdings); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.PortfolioHoldingItem.Holdings exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Holdings {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PortfolioHoldingItem size exceeds %d bytes", ColferSizeMax))
		}
	}

	if x := len(o.Justification); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.PortfolioHoldingItem.Justification exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Justification {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PortfolioHoldingItem size exceeds %d bytes", ColferSizeMax))
		}
	}

	if o.PercentReturn != 0 {
		l += 9
	}

	if o.Value != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.PortfolioHoldingItem exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// All nil entries in o.Holdings will be replaced with a new value.
// All nil entries in o.Justification will be replaced with a new value.
// The error return option is portfolio.ColferMax.
func (o *PortfolioHoldingItem) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *PortfolioHoldingItem) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Time = time.Unix(int64(intconv.Uint32(data[start:])), int64(intconv.Uint32(data[start+4:]))).In(time.UTC)
		header = data[i]
		i++
	} else if header == 0|0x80 {
		start := i
		i += 12
		if i >= len(data) {
			goto eof
		}
		o.Time = time.Unix(int64(intconv.Uint64(data[start:])), int64(intconv.Uint32(data[start+8:]))).In(time.UTC)
		header = data[i]
		i++
	}

	if header == 1 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PortfolioHoldingItem.Holdings length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*ReportableHolding, l)
		malloc := make([]ReportableHolding, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PortfolioHoldingItem size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Holdings = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 2 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PortfolioHoldingItem.Justification length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*Justification, l)
		malloc := make([]Justification, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PortfolioHoldingItem size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Justification = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 3 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.PercentReturn = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 4 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Value = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PortfolioHoldingItem size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *PortfolioHoldingItem) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type PortfolioHoldingItemList struct {
	Items []*PortfolioHoldingItem
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
// All nil entries in o.Items will be replaced with a new value.
func (o *PortfolioHoldingItemList) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.Items); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Items {
			if v == nil {
				v = new(PortfolioHoldingItem)
				o.Items[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *PortfolioHoldingItemList) MarshalLen() (int, error) {
	l := 1

	if x := len(o.Items); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.PortfolioHoldingItemList.Items exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Items {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PortfolioHoldingItemList size exceeds %d bytes", ColferSizeMax))
		}
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.PortfolioHoldingItemList exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// All nil entries in o.Items will be replaced with a new value.
// The error return option is portfolio.ColferMax.
func (o *PortfolioHoldingItemList) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *PortfolioHoldingItemList) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PortfolioHoldingItemList.Items length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*PortfolioHoldingItem, l)
		malloc := make([]PortfolioHoldingItem, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PortfolioHoldingItemList size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Items = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PortfolioHoldingItemList size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *PortfolioHoldingItemList) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type PortfolioTransactionList struct {
	Items []*Transaction
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
// All nil entries in o.Items will be replaced with a new value.
func (o *PortfolioTransactionList) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.Items); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Items {
			if v == nil {
				v = new(Transaction)
				o.Items[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is portfolio.ColferMax.
func (o *PortfolioTransactionList) MarshalLen() (int, error) {
	l := 1

	if x := len(o.Items); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field portfolio.PortfolioTransactionList.Items exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Items {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if l > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PortfolioTransactionList size exceeds %d bytes", ColferSizeMax))
		}
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct portfolio.PortfolioTransactionList exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// All nil entries in o.Items will be replaced with a new value.
// The error return option is portfolio.ColferMax.
func (o *PortfolioTransactionList) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, portfolio.ColferError and portfolio.ColferMax.
func (o *PortfolioTransactionList) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PortfolioTransactionList.Items length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*Transaction, l)
		malloc := make([]Transaction, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: portfolio.PortfolioTransactionList size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Items = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct portfolio.PortfolioTransactionList size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, portfolio.ColferError, portfolio.ColferTail and portfolio.ColferMax.
func (o *PortfolioTransactionList) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}
